use crate::backend::errors::{FluxError, Result};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

// ============================================================================
// MACROS FOR VALUE CONVERSIONS
// ============================================================================

/// Implements `From<T>` for [`Value`] for the specified primitive and structured types.
///
/// This macro simplifies conversion of Rust types into the [`Value`] enum by
/// generating boilerplate `From<T>` implementations.
///
/// # Example
/// ```
/// let v: Value = 42_i32.into();
/// ```
macro_rules! impl_from_value {
    ($($type:ty => $variant:ident),+ $(,)?) => {
        $(
            impl From<$type> for Value {
                /// Converts the given value into a [`Value`] enum variant.
                ///
                /// This implementation is auto-generated by [`impl_from_value!`].
                fn from(v: $type) -> Self {
                    Value::$variant(v)
                }
            }
        )+
    };
}

/// Implements `TryFrom<Value>` and `TryFrom<&Value>` for different categories of types.
///
/// The macro supports:
/// - `copy:` — Copy types, returned by value.
/// - `clone:` — Clone types (e.g. `String`, `Vec<u8>`).
/// - `numeric:` — Numeric types with automatic coercion.
///
/// This macro allows ergonomic conversion **from stored values to native types**.
///
/// # Errors
/// If conversion is not possible (wrong type or unsupported coercion),
/// a [`FluxError`] is returned.
macro_rules! impl_try_from_value {

    // ---------------------- COPY TYPES ----------------------
    (copy: $($rust_type:ty => $variant:ident),+ $(,)?) => {
        $(
            impl TryFrom<Value> for $rust_type {
                type Error = FluxError;

                /// Attempts to extract a copy-type value from a [`Value`] instance.
                ///
                /// Returns an error if the variant does not match.
                fn try_from(value: Value) -> Result<Self> {
                    match value {
                        Value::$variant(v) => Ok(v),
                        _ => Err(FluxError::conversion_error(&value, stringify!($rust_type))),
                    }
                }
            }

            impl TryFrom<&Value> for $rust_type {
                type Error = FluxError;

                /// Attempts to extract a copy-type value by reference.
                ///
                /// Returns an error if the variant does not match.
                fn try_from(value: &Value) -> Result<Self> {
                    match value {
                        Value::$variant(v) => Ok(*v),
                        _ => Err(FluxError::conversion_error(value, stringify!($rust_type))),
                    }
                }
            }
        )+
    };

    // ---------------------- CLONE TYPES ----------------------
    (clone: $($rust_type:ty => $variant:ident),+ $(,)?) => {
        $(
            impl TryFrom<Value> for $rust_type {
                type Error = FluxError;

                /// Consumes a [`Value`] and returns the inner clone-type data.
                ///
                /// Returns an error if the variant differs.
                fn try_from(value: Value) -> Result<Self> {
                    match value {
                        Value::$variant(v) => Ok(v),
                        _ => Err(FluxError::conversion_error(&value, stringify!($rust_type))),
                    }
                }
            }

            impl TryFrom<&Value> for $rust_type {
                type Error = FluxError;

                /// Attempts to clone out the inner data.
                ///
                /// Returns an error if the type does not match.
                fn try_from(value: &Value) -> Result<Self> {
                    match value {
                        Value::$variant(v) => Ok(v.clone()),
                        _ => Err(FluxError::conversion_error(value, stringify!($rust_type))),
                    }
                }
            }
        )+
    };

    // ---------------------- NUMERIC TYPES ----------------------
    (numeric: $rust_type:ty => $primary:ident, [$($alt:ident),*] $(,)?) => {
        impl TryFrom<Value> for $rust_type {
            type Error = FluxError;

            /// Converts a numeric [`Value`] into the target numeric Rust type.
            ///
            /// Performs automatic widening/narrowing where allowed.
            ///
            /// Returns an error for incompatible types.
            fn try_from(value: Value) -> Result<Self> {
                match value {
                    Value::$primary(v) => Ok(v),
                    $(Value::$alt(v) => Ok(v as $rust_type),)*
                    _ => Err(FluxError::conversion_error(&value, stringify!($rust_type))),
                }
            }
        }

        impl TryFrom<&Value> for $rust_type {
            type Error = FluxError;

            /// Attempts numeric extraction by reference with automatic coercion.
            fn try_from(value: &Value) -> Result<Self> {
                match value {
                    Value::$primary(v) => Ok(*v),
                    $(Value::$alt(v) => Ok(*v as $rust_type),)*
                    _ => Err(FluxError::conversion_error(value, stringify!($rust_type))),
                }
            }
        }
    };
}

// ============================================================================
// VALUE ENUM
// ============================================================================

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum Value {
    /// Represents SQL/JSON-style null.
    Null,

    /// Boolean value.
    Bool(bool),

    /// 16-bit signed integer.
    I16(i16),

    /// 32-bit signed integer.
    I32(i32),

    /// 64-bit signed integer.
    I64(i64),

    /// 32-bit floating-point.
    F32(f32),

    /// 64-bit floating-point.
    F64(f64),

    /// UTF-8 string.
    String(String),

    /// Raw byte array / BLOB.
    Bytes(Vec<u8>),

    /// Timestamp in UTC.
    DateTime(DateTime<Utc>),

    /// UUID value.
    Uuid(Uuid),

    /// Arbitrary JSON.
    Json(serde_json::Value),

    /// Decimal number (optional feature).
    #[cfg(feature = "rust_decimal")]
    Decimal(rust_decimal::Decimal),

    /// String fallback for decimals.
    #[cfg(not(feature = "rust_decimal"))]
    DecimalString(String),

    /// Array of nested values.
    Array(Vec<Value>),

    /// Enum represented as string.
    Enum(String),
}

// ============================================================================
// HELPER TRAIT
// ============================================================================

trait ConversionError {
    /// Constructs a type conversion error describing what failed.
    ///
    /// # Parameters
    /// - `value`: The value that failed to convert.
    /// - `target`: Name of the expected type.
    fn conversion_error(value: &Value, target: &str) -> Self;
}

impl ConversionError for FluxError {
    fn conversion_error(value: &Value, target: &str) -> Self {
        FluxError::Serialization(format!("Cannot convert {:?} to {}", value, target))
    }
}

// ============================================================================
// FROM IMPLEMENTATIONS
// ============================================================================

impl_from_value! {
    bool => Bool,
    i16 => I16,
    i32 => I32,
    i64 => I64,
    f32 => F32,
    f64 => F64,
    String => String,
    Uuid => Uuid,
    DateTime<Utc> => DateTime,
    Vec<u8> => Bytes,
    serde_json::Value => Json,
}

/// Converts `&str` into a [`Value::String`].
impl From<&str> for Value {
    /// Creates a new string [`Value`] by copying the provided string slice.
    fn from(v: &str) -> Self {
        Value::String(v.to_string())
    }
}

impl<T: Into<Value>> From<Option<T>> for Value {
    /// Converts an `Option<T>` into a [`Value`].
    ///
    /// - `None` becomes [`Value::Null`]
    /// - `Some(x)` becomes `Value::from(x)`
    fn from(v: Option<T>) -> Self {
        v.map_or(Value::Null, Into::into)
    }
}

// ============================================================================
// TRY_FROM IMPLEMENTATIONS
// ============================================================================

// Numeric types
impl_try_from_value!(numeric: i16 => I16, [I32, I64]);
impl_try_from_value!(numeric: i32 => I32, [I16, I64]);
impl_try_from_value!(numeric: i64 => I64, [I16, I32]);
impl_try_from_value!(numeric: f32 => F32, [F64]);
impl_try_from_value!(numeric: f64 => F64, [F32]);

// Clone types
impl_try_from_value!(clone: String => String, Vec<u8> => Bytes);

// ---------------------------------------------------------------------------
// BOOL
// ---------------------------------------------------------------------------

impl TryFrom<Value> for bool {
    type Error = FluxError;

    /// Converts a [`Value`] into a `bool`, accepting:
    /// - `Value::Bool`
    /// - integer types (`!= 0` → `true`)
    ///
    /// Returns error for incompatible types.
    fn try_from(value: Value) -> Result<Self> {
        Self::try_from(&value)
    }
}

impl TryFrom<&Value> for bool {
    type Error = FluxError;

    /// Converts a reference to [`Value`] into a `bool`.
    ///
    /// Non-zero integers are treated as `true`.
    fn try_from(value: &Value) -> Result<Self> {
        match value {
            Value::Bool(v) => Ok(*v),
            Value::I16(v) => Ok(*v != 0),
            Value::I32(v) => Ok(*v != 0),
            Value::I64(v) => Ok(*v != 0),
            _ => Err(FluxError::conversion_error(value, "bool")),
        }
    }
}

// ---------------------------------------------------------------------------
// DATETIME
// ---------------------------------------------------------------------------

impl TryFrom<Value> for DateTime<Utc> {
    type Error = FluxError;

    /// Converts a value into a `DateTime<Utc>`.
    ///
    /// Accepts:
    /// - `Value::DateTime`
    /// - `Value::String` (parsed)
    fn try_from(value: Value) -> Result<Self> {
        Self::try_from(&value)
    }
}

impl TryFrom<&Value> for DateTime<Utc> {
    type Error = FluxError;

    /// Attempts to extract a UTC timestamp from a [`Value`].
    fn try_from(value: &Value) -> Result<Self> {
        match value {
            Value::DateTime(dt) => Ok(*dt),
            Value::String(s) => s
                .parse()
                .map_err(|e| FluxError::Serialization(format!("Cannot parse DateTime: {}", e))),
            _ => Err(FluxError::conversion_error(value, "DateTime")),
        }
    }
}

// ---------------------------------------------------------------------------
// UUID
// ---------------------------------------------------------------------------

impl TryFrom<Value> for Uuid {
    type Error = FluxError;

    /// Converts a [`Value`] into a [`Uuid`].
    ///
    /// Accepts:
    /// - `Value::Uuid`
    /// - `Value::String` (parsed)
    fn try_from(value: Value) -> Result<Self> {
        Self::try_from(&value)
    }
}

impl TryFrom<&Value> for Uuid {
    type Error = FluxError;

    /// Extracts or parses a UUID from a [`Value`].
    fn try_from(value: &Value) -> Result<Self> {
        match value {
            Value::Uuid(u) => Ok(*u),
            Value::String(s) => Uuid::parse_str(s)
                .map_err(|e| FluxError::Serialization(format!("Cannot parse UUID: {}", e))),
            _ => Err(FluxError::conversion_error(value, "UUID")),
        }
    }
}

// ---------------------------------------------------------------------------
// JSON
// ---------------------------------------------------------------------------

impl TryFrom<Value> for serde_json::Value {
    type Error = FluxError;

    /// Converts a [`Value`] into JSON.
    ///
    /// Accepts:
    /// - `Value::Json`
    /// - `Value::String` (parsed)
    fn try_from(value: Value) -> Result<Self> {
        match value {
            Value::Json(v) => Ok(v),
            Value::String(s) => serde_json::from_str(&s)
                .map_err(|e| FluxError::Serialization(format!("Cannot parse JSON: {}", e))),
            other => Self::try_from(&other),
        }
    }
}

impl TryFrom<&Value> for serde_json::Value {
    type Error = FluxError;

    /// Converts a borrowed [`Value`] into JSON.
    fn try_from(value: &Value) -> Result<Self> {
        match value {
            Value::Json(v) => Ok(v.clone()),
            Value::String(s) => serde_json::from_str(s)
                .map_err(|e| FluxError::Serialization(format!("Cannot parse JSON: {}", e))),
            _ => Err(FluxError::conversion_error(value, "JSON")),
        }
    }
}

// ============================================================================
// VALUE GETTERS
// ============================================================================

macro_rules! impl_getters {
    (
        simple: {$($method:ident -> $variant:ident: $type:ty),+ $(,)?},
        clone: {$($clone_method:ident -> $clone_variant:ident: $clone_type:ty),+ $(,)?},
        ref: {$($ref_method:ident -> $ref_variant:ident: $ret_type:ty),+ $(,)?}
    ) => {
        impl Value {

            /// Returns `true` if the value is [`Value::Null`].
            pub fn is_null(&self) -> bool {
                matches!(self, Value::Null)
            }

            // ---------------------- SIMPLE GETTERS ----------------------
            $(
                #[doc = concat!("Returns the inner `", stringify!($type), "` if this is `Value::", stringify!($variant), "`.")]
                pub fn $method(&self) -> Option<$type> {
                    match self {
                        Value::$variant(v) => Some(*v),
                        _ => None,
                    }
                }
            )+

            // ---------------------- CLONE GETTERS ----------------------
            $(
                #[doc = concat!("Returns a cloned `", stringify!($clone_type), "` if this is `Value::", stringify!($clone_variant), "`.")]
                pub fn $clone_method(&self) -> Option<$clone_type> {
                    match self {
                        Value::$clone_variant(v) => Some(v.clone()),
                        _ => None,
                    }
                }
            )+

            // ---------------------- REF GETTERS ----------------------
            $(
                #[doc = concat!("Returns a reference to the inner `", stringify!($ret_type), "` if this is `Value::", stringify!($ref_variant), "`.")]
                pub fn $ref_method(&self) -> Option<$ret_type> {
                    match self {
                        Value::$ref_variant(v) => Some(v),
                        _ => None,
                    }
                }
            )+
        }
    };
}

impl_getters! {
    simple: {
        as_datetime -> DateTime: DateTime<Utc>,
        as_uuid -> Uuid: Uuid,
    },
    clone: {
        as_string -> String: String,
        as_json -> Json: serde_json::Value,
    },
    ref: {
        as_str -> String: &str,
        as_bytes -> Bytes: &[u8],
    }
}

// ============================================================================
// NUMERIC GETTERS
// ============================================================================

impl Value {

    /// Attempts to extract an `i16` with safe narrowing conversion.
    ///
    /// Returns:
    /// - Exact `i16`
    /// - Narrowed from `i32`/`i64` when within range
    pub fn as_i16(&self) -> Option<i16> {
        match self {
            Value::I16(v) => Some(*v),
            Value::I32(v) if *v >= i16::MIN as i32 && *v <= i16::MAX as i32 => Some(*v as i16),
            Value::I64(v) if *v >= i16::MIN as i64 && *v <= i16::MAX as i64 => Some(*v as i16),
            _ => None,
        }
    }

    /// Attempts to extract an `i32` with widening/narrowing logic.
    pub fn as_i32(&self) -> Option<i32> {
        match self {
            Value::I16(v) => Some(*v as i32),
            Value::I32(v) => Some(*v),
            Value::I64(v) if *v >= i32::MIN as i64 && *v <= i32::MAX as i64 => Some(*v as i32),
            _ => None,
        }
    }

    /// Attempts to extract an `i64` with safe widening.
    pub fn as_i64(&self) -> Option<i64> {
        match self {
            Value::I16(v) => Some(*v as i64),
            Value::I32(v) => Some(*v as i64),
            Value::I64(v) => Some(*v),
            _ => None,
        }
    }

    /// Extracts `f32`, accepting `f64` with loss of precision.
    pub fn as_f32(&self) -> Option<f32> {
        match self {
            Value::F32(v) => Some(*v),
            Value::F64(v) => Some(*v as f32),
            _ => None,
        }
    }

    /// Extracts `f64`, widening from `f32`.
    pub fn as_f64(&self) -> Option<f64> {
        match self {
            Value::F32(v) => Some(*v as f64),
            Value::F64(v) => Some(*v),
            _ => None,
        }
    }

    /// Extracts a boolean, accepting integer coercion.
    ///
    /// Non-zero integers become `true`.
    pub fn as_bool(&self) -> Option<bool> {
        match self {
            Value::Bool(b) => Some(*b),
            Value::I16(i) => Some(*i != 0),
            Value::I32(i) => Some(*i != 0),
            Value::I64(i) => Some(*i != 0),
            _ => None,
        }
    }
}
